@using System.Security.Claims
@{
    ViewData["Title"] = "Admin Chat Dashboard";
    Layout = "~/Areas/Admin/Views/Shared/_Layout.cshtml";

    // Get user ID manually
    var currentUserId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
}

<!-- Hidden field for user ID -->
<input type="hidden" id="current-user-id" value="@currentUserId" />

<div class="container-fluid">
    <div class="row">
        <div class="col-md-4">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0">Active Conversations</h5>
                </div>
                <div class="card-body p-0">
                    <div id="conversation-list" style="max-height: 500px; overflow-y: auto;">
                        <p class="text-muted p-3 mb-0">Loading conversations...</p>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-8">
            <div class="card">
                <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                    <h5 id="current-conversation" class="mb-0">Select a conversation</h5>
                    <span id="user-status" class="badge bg-light text-dark"></span>
                </div>
                <div class="card-body">
                    <div id="chat-messages" style="height: 400px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 5px; padding: 15px; margin-bottom: 15px; background-color: #f8f9fa;">
                        <div class="text-center text-muted">
                            <i class="fas fa-comments fa-3x mb-2"></i>
                            <p>Select a user to start chatting</p>
                        </div>
                    </div>
                    <div class="mt-3">
                        <textarea id="message-input" class="form-control" placeholder="Type your message..." rows="3" disabled style="resize: none;"></textarea>
                        <div class="d-flex justify-content-between align-items-center mt-2">
                            <small class="text-muted">Press Enter to send, Shift+Enter for new line</small>
                            <button id="send-button" class="btn btn-primary" disabled>
                                <i class="fas fa-paper-plane me-1"></i> Send
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
    <script>
        let connection = null;
        let currentUserId = null;
        let currentConversationUserId = null;
        let conversations = [];

        // Initialize SignalR connection
        function initSignalR() {
            connection = new signalR.HubConnectionBuilder()
                .withUrl("/chatHub")
                .configureLogging(signalR.LogLevel.Information)
                .build();

            // Handle incoming messages
            connection.on("ReceiveMessage", (message) => {
                console.log('📩 Received real-time message:', message);

                // Update conversations list with new message
                updateConversationsWithNewMessage(message);

                // Check if this message belongs to the current conversation
                const isForCurrentConversation = checkIfMessageForCurrentConversation(message);

                if (isForCurrentConversation) {
                    console.log('✅ Adding message to current conversation');
                    addMessageToChat(message, false);
                    markMessageAsRead(message);
                } else {
                    console.log('ℹ️ Message received for different conversation');
                    // Show notification for new message in other conversation
                    showNewMessageNotification(message);
                }

                // Refresh conversations list to show new message indicator
                updateConversationListUI();
            });

            // Handle connection status
            connection.onclose(() => {
                console.log("SignalR connection closed");
                showConnectionStatus(false);
            });

            connection.onreconnected(() => {
                console.log("SignalR connection reestablished");
                showConnectionStatus(true);
                loadConversations();
            });

            // Start connection
            connection.start()
                .then(() => {
                    console.log("SignalR Connected");
                    showConnectionStatus(true);
                    loadConversations();
                })
                .catch(err => {
                    console.error("SignalR Connection Error:", err);
                    showConnectionStatus(false);
                });
        }

        function checkIfMessageForCurrentConversation(message) {
            if (!currentConversationUserId) return false;

            const messageSenderId = message.senderId ? message.senderId.toString() : '';
            const messageReceiverId = message.receiverId ? message.receiverId.toString() : null;
            const currentUserIdStr = currentUserId ? currentUserId.toString() : '';
            const currentConversationStr = currentConversationUserId.toString();

            return (messageSenderId === currentConversationStr && messageReceiverId === currentUserIdStr) ||
                   (messageSenderId === currentUserIdStr && messageReceiverId === currentConversationStr);
        }

        function updateConversationsWithNewMessage(message) {
            const otherUserId = message.senderId === currentUserId ? message.receiverId : message.senderId;
            if (!otherUserId) return;

            const conversation = conversations.find(c => c.userId === otherUserId);
            if (conversation) {
                conversation.lastMessage = message;
                conversation.unreadCount = (conversation.unreadCount || 0) + 1;
            } else {
                conversations.push({
                    userId: otherUserId,
                    lastMessage: message,
                    unreadCount: 1,
                    displayName: message.senderName || 'User'
                });
            }
        }

        function markMessageAsRead(message) {
            // In a real app, you'd call an API to mark the message as read
            console.log('Marking message as read:', message.id);
        }

        function showNewMessageNotification(message) {
            // Simple notification - you can enhance this with toast notifications
            const notification = document.createElement('div');
            notification.className = 'alert alert-info alert-dismissible fade show';
            notification.innerHTML = '<strong>New message from ' + (message.senderName || 'User') + ':</strong> ' +
                                   (message.content ? message.content.substring(0, 50) : '') + '...' +
                                   '<button type="button" class="btn-close" data-bs-dismiss="alert"></button>';
            document.body.appendChild(notification);

            // Auto remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }

        function showConnectionStatus(connected) {
            const statusElement = document.getElementById('user-status');
            if (statusElement) {
                statusElement.textContent = connected ? '🟢 Online' : '🔴 Offline';
                statusElement.className = connected ? 'badge bg-success' : 'badge bg-danger';
            }
        }

        // Load conversations list - FIXED ENDPOINT
        async function loadConversations() {
            try {
                showLoadingState(true);
                console.log('Loading conversations from /Chat/GetMessages');
                const response = await fetch('/Chat/GetMessages'); // FIXED: Changed from '/chat/api/messages'

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server responded with ${response.status}: ${errorText}`);
                }

                const messages = await response.json();
                console.log('Successfully loaded messages:', messages);
                processConversations(messages);
                updateConversationListUI();
            } catch (error) {
                console.error("Error loading conversations:", error);
                showError("Failed to load conversations: " + error.message);

                // Show error in conversation list
                const conversationList = document.getElementById('conversation-list');
                if (conversationList) {
                    conversationList.innerHTML = '<p class="text-danger p-3">Error loading conversations. Please refresh the page.</p>';
                }
            } finally {
                showLoadingState(false);
            }
        }

        function processConversations(messages) {
            conversations = [];
            const userMessages = {};

            // Group messages by user
            messages.forEach(msg => {
                const otherUserId = msg.senderId === currentUserId ? msg.receiverId : msg.senderId;
                if (otherUserId) {
                    if (!userMessages[otherUserId]) {
                        userMessages[otherUserId] = [];
                    }
                    userMessages[otherUserId].push(msg);
                }
            });

            // Create conversation objects
            Object.keys(userMessages).forEach(userId => {
                const userMsgs = userMessages[userId];

                // Sort messages by date to get the last one correctly
                userMsgs.sort((a, b) => new Date(b.sentAt) - new Date(a.sentAt));
                const lastMessage = userMsgs[0]; // Get the most recent message

                // Find the OTHER user's name (not the current user's name)
                let otherUserName = 'User';

                // Look for a message from the other user to get their actual name
                const messageFromOtherUser = userMsgs.find(msg => msg.senderId !== currentUserId);
                if (messageFromOtherUser && messageFromOtherUser.senderName) {
                    otherUserName = messageFromOtherUser.senderName;
                } else {
                    // Fallback: use the name from any message that's not from admin
                    const nonAdminMessage = userMsgs.find(msg => !msg.isFromAdmin && msg.senderName);
                    if (nonAdminMessage) {
                        otherUserName = nonAdminMessage.senderName;
                    } else {
                        // Ultimate fallback
                        otherUserName = 'User: ' + userId.substring(0, 8) + '...';
                    }
                }

                conversations.push({
                    userId: userId,
                    messages: userMsgs,
                    lastMessage: lastMessage,
                    displayName: otherUserName,
                    unreadCount: userMsgs.filter(m => !m.isRead && m.senderId !== currentUserId).length
                });
            });

            // Sort by last message time
            conversations.sort((a, b) => new Date(b.lastMessage.sentAt) - new Date(a.lastMessage.sentAt));
        }

        // Update conversation list UI
        function updateConversationListUI() {
            const conversationList = document.getElementById('conversation-list');
            if (!conversationList) return;

            if (conversations.length === 0) {
                conversationList.innerHTML = '<p class="text-muted p-3 mb-0">No conversations yet</p>';
                return;
            }

            let conversationHTML = '';
            conversations.forEach(conv => {
                const unreadBadge = conv.unreadCount > 0 ?
                    '<span class="badge bg-danger ms-2">' + conv.unreadCount + '</span>' : '';

                conversationHTML += `
                    <div class="conversation-item p-3 border-bottom ${conv.userId === currentConversationUserId ? 'bg-light' : ''}"
                         onclick="selectConversation('${conv.userId}')"
                         style="cursor: pointer; transition: background-color 0.2s;">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
                                <div class="fw-bold d-flex align-items-center">
                                    ${conv.displayName}
                                    ${unreadBadge}
                                </div>
                                <div class="text-muted small text-truncate">${conv.lastMessage.content || ''}</div>
                                <div class="text-muted smaller">${formatTime(conv.lastMessage.sentAt)}</div>
                            </div>
                            <div class="ms-2">
                                <i class="fas fa-chevron-right text-muted"></i>
                            </div>
                        </div>
                    </div>
                `;
            });

            conversationList.innerHTML = conversationHTML;
        }

        function selectConversation(userId) {
            currentConversationUserId = userId;
            loadConversation(userId);
            updateConversationListUI();
        }

        // Load specific conversation - FIXED ENDPOINT
        async function loadConversation(userId) {
            try {
                showLoadingState(true);
                console.log('Loading conversation for user:', userId);
                const response = await fetch('/Chat/GetMessages?userId=' + userId); // FIXED: Changed from '/chat/api/messages'

                if (!response.ok) {
                    throw new Error('Failed to load conversation');
                }

                const messages = await response.json();
                console.log('Successfully loaded conversation messages:', messages);

                const currentConversationEl = document.getElementById('current-conversation');
                const messageInput = document.getElementById('message-input');
                const sendButton = document.getElementById('send-button');

                // Find the OTHER user's name from the messages
                let otherUserName = 'User';
                const messageFromOtherUser = messages.find(msg => msg.senderId !== currentUserId);
                if (messageFromOtherUser && messageFromOtherUser.senderName) {
                    otherUserName = messageFromOtherUser.senderName;
                } else {
                    const conversation = conversations.find(c => c.userId === userId);
                    otherUserName = conversation ? conversation.displayName : 'User: ' + userId.substring(0, 8) + '...';
                }

                if (currentConversationEl) {
                    currentConversationEl.textContent = 'Conversation with ' + otherUserName;
                }

                if (messageInput) messageInput.disabled = false;
                if (sendButton) sendButton.disabled = false;

                displayMessages(messages);

                // Clear unread count for this conversation
                const conv = conversations.find(c => c.userId === userId);
                if (conv) {
                    conv.unreadCount = 0;
                }

            } catch (error) {
                console.error("Error loading conversation:", error);
                showError("Failed to load conversation: " + error.message);
            } finally {
                showLoadingState(false);
            }
        }

        function displayMessages(messages) {
            const chatMessages = document.getElementById('chat-messages');
            if (!chatMessages) return;

            chatMessages.innerHTML = '';

            if (messages.length === 0) {
                chatMessages.innerHTML = '<div class="text-center text-muted"><p>No messages yet. Start the conversation!</p></div>';
                return;
            }

            messages.forEach(msg => {
                addMessageToChat(msg, true);
            });

            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Add message to chat UI
        function addMessageToChat(message, isHistorical) {
            const chatMessages = document.getElementById('chat-messages');
            if (!chatMessages) return;

            // Clear placeholder if it's the first message
            if (chatMessages.querySelector('.text-center')) {
                chatMessages.innerHTML = '';
            }

            const messageDiv = document.createElement('div');
            const messageSenderId = message.senderId ? message.senderId.toString() : '';
            const currentUserIdStr = currentUserId ? currentUserId.toString() : '';
            const isFromMe = messageSenderId === currentUserIdStr;

            messageDiv.className = 'message ' + (isFromMe ? 'message-sent' : 'message-received');

            const displayName = message.senderName || (message.isFromAdmin ? 'Admin' : 'User');
            const senderHtml = !isFromMe ? '<div class="message-sender small fw-bold">' + displayName + '</div>' : '';

            messageDiv.innerHTML = `
                <div class="message-content ${message.isFromAdmin ? 'admin-message' : ''}">
                    ${senderHtml}
                    <div class="message-text">${escapeHtml(message.content || '')}</div>
                    <div class="message-time">${formatTime(message.sentAt)}</div>
                </div>
            `;

            chatMessages.appendChild(messageDiv);

            if (!isHistorical) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }

        // Send message - IMPROVED WITH BETTER ERROR HANDLING
               // Send message - FIXED DUPLICATE MESSAGE ISSUE
        async function sendMessage() {
            const input = document.getElementById('message-input');
            if (!input) return;

            const content = input.value.trim();
            if (!content || !currentConversationUserId) return;

            try {
                // Create optimistic message
                const optimisticMessage = {
                    id: 'temp-' + Date.now(),
                    senderId: currentUserId,
                    senderName: 'You',
                    receiverId: currentConversationUserId,
                    content: content,
                    sentAt: new Date().toISOString(),
                    isFromAdmin: true,
                    isOptimistic: true
                };

                // Add to UI immediately
                addMessageToChat(optimisticMessage, false);

                // Clear input immediately
                input.value = '';
                input.focus();

                // CHOOSE ONE METHOD - Either API OR SignalR, not both!

                // Option 1: Send via API only (recommended - more reliable)
                await fetch('/Chat/Send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    },
                    body: JSON.stringify({
                        receiverId: currentConversationUserId,
                        content: content
                    })
                });

                // Option 2: Or send via SignalR only (for real-time)
                // await connection.invoke("SendMessageToUser", currentConversationUserId.toString(), content);

                console.log('Message sent successfully');

            } catch (error) {
                console.error("Error sending message:", error);
                showError('Failed to send message. Please try again.');

                // Remove optimistic message on error
                const tempMessage = document.querySelector('[id*="temp-"]');
                if (tempMessage) {
                    tempMessage.remove();
                }

                // Restore the message content to input so user can try again
                input.value = content;
            }
        }

        // Utility functions
        function formatTime(dateString) {
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) {
                    return 'Invalid date';
                }
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } catch (error) {
                console.error('Error formatting date:', dateString, error);
                return 'Unknown time';
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showLoadingState(loading) {
            if (loading) {
                document.body.style.cursor = 'wait';
            } else {
                document.body.style.cursor = 'default';
            }
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'alert alert-danger alert-dismissible fade show position-fixed';
            errorDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
            errorDiv.innerHTML = '<strong>Error:</strong> ' + message +
                               '<button type="button" class="btn-close" data-bs-dismiss="alert"></button>';
            document.body.appendChild(errorDiv);

            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.remove();
                }
            }, 5000);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Get current user ID from hidden field
            const userIdElement = document.getElementById('current-user-id');
            if (userIdElement && userIdElement.value) {
                currentUserId = userIdElement.value;
                console.log('Current user ID:', currentUserId);
            } else {
                console.error('Current user ID not found');
                showError('User authentication error');
                return;
            }

            initSignalR();

            // Set up send button
            const sendButton = document.getElementById('send-button');
            if (sendButton) {
                sendButton.onclick = sendMessage;
            }

            // Send on Enter key
            const messageInput = document.getElementById('message-input');
            if (messageInput) {
                messageInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });

                // Auto-resize textarea
                messageInput.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = (this.scrollHeight) + 'px';
                });
            }
        });
    </script>

    <style>
        .message {
            margin-bottom: 15px;
        }

        .message-sent {
            text-align: right;
        }

        .message-received {
            text-align: left;
        }

        .message-content {
            display: inline-block;
            padding: 12px 16px;
            border-radius: 18px;
            max-width: 70%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            animation: fadeIn 0.3s ease-in;
        }

        .message-sent .message-content {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border-bottom-right-radius: 5px;
        }

        .message-received .message-content {
            background: white;
            color: #333;
            border-bottom-left-radius: 5px;
            border: 1px solid #e9ecef;
        }

        .admin-message {
            border-left: 4px solid #28a745;
        }

        .message-sender {
            margin-bottom: 4px;
            opacity: 0.8;
        }

        .message-time {
            font-size: 0.75em;
            opacity: 0.7;
            margin-top: 4px;
        }

        .conversation-item {
            transition: background-color 0.2s ease;
        }

            .conversation-item:hover {
                background-color: #f8f9fa !important;
            }

        #chat-messages {
            background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 100%);
        }

        /* Keyframes animation */
        @@keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Scrollbar styling */
        #chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        #chat-messages::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        #chat-messages::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

            #chat-messages::-webkit-scrollbar-thumb:hover {
                background: #a8a8a8;
            }
    </style>
}